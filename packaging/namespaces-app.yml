
#@ load("@ytt:data", "data")
#@ load("@ytt:yaml", "yaml")

---
#@ def namespaces():
- justin
- mae
- aiden
- travis
#@ end

---
#@ def config():
namespaces:
  #@ for val in namespaces():
  - name: #@ val
  #@ end
#@ end

---
#@ def namespaceLabels():
apps.tanzu.vmware.com/tap-ns: ""
#@ end

#! ^^^^^^^^^^^^^^^ Everything above is unique per cluster/profile ^^^^^^^^^^^^^^^^^^^^^^^^^
#! vvvvvvvvvvvvvvv Everything below is consistent for cluster regardless of vvvvvvvvvvvvvvv

#@ def getNamespaces():
#@ for val in namespaces():
---
apiVersion: v1
kind: Namespace
metadata:
  name: #@ val
  labels: #@ namespaceLabels()
#@ end
#@ end

#@ def desiredNamespacesConfigMap():
apiVersion: v1
kind: ConfigMap
metadata:
  name: desired-namespaces
  namespace: tap-namespace-provisioning
  annotations:
    kapp.k14s.io/create-strategy: fallback-on-update
    namespace-provisioner.apps.tanzu.vmware.com/no-overwrite: "" #! This annotation tells the provisioner app to not override this configMap as this is your desired state.
data:
  #@yaml/text-templated-strings
  desired-namespaces.yaml: |
    #@data/values
    ---
    (@= yaml.encode(config()) @)
#@ end

---
apiVersion: kappctrl.k14s.io/v1alpha1
kind: App
metadata:
  name: desired-namespaces
  namespace: tap-install
  annotations:
    kapp.k14s.io/change-group: desired-namespaces
    kapp.k14s.io/change-rule: "upsert after upserting tap"
spec:
  serviceAccountName: tap-install-gitops-sa
  syncPeriod: 1m
  fetch:
    - inline:
        paths:
          namespaces.yaml: #@ yaml.encode(getNamespaces())
          desired-namespaces.yaml: #@ yaml.encode(desiredNamespacesConfigMap())
  template:
    - ytt: {}
  deploy:
    - kapp:
        rawOptions: ["--dangerous-override-ownership-of-existing-resources=true"] #! required because the configmap is already owned by the original package
